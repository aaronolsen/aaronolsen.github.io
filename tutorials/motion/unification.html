<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<title>Animation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="shortcut icon" href="../../img/favicon.png"/>
<link href="../../css/stylesheet2.css" rel="stylesheet" type="text/css">

<body>
	<div id='container' class='container'>

		<div id='header' class='header' >
			<div style='position:relative;' >
				<img id='header_image' style='float:right;' src='../../img/headers/Great Horned Owl.jpg' />
				<div id='header_image_caption' style='color:white' class='header_image_caption' >
					Great Horned Owl
				</div>
			</div>
		</div>

		<div id='linksidebar' class='linksidebar' >
			<div class='linksidebar_mainlink' >
				<a class='linksidebar_link' href='../../about_me.html'>About me</a>
			</div>
			<div class='linksidebar_mainlink' >
				<a class='linksidebar_link' href='../../current_projects.html'>Current projects</a>
			</div>
			<div class='linksidebar_mainlink' >
				<a class='linksidebar_link' href='../../software.html'>Software</a>
			</div>
			<div class='linksidebar_mainlink' >
				<a class='linksidebar_link' href='../../tutorials/visualization3d.html'>Tutorials</a>
			</div>
			<div class='linksidebar_sublink' >
				<a class='linksidebar_link' href='../../tutorials/visualization3d.html'>3D Visualization</a>
			</div>
			<div class='linksidebar_sublink' >
				<a class='linksidebar_link' href='../../tutorials/morphometrics.html'>Shape analysis</a>
			</div>
			<div class='linksidebar_sublink' >
				<a class='linksidebar_link' href='../../tutorials/motion.html'>Motion analysis</a>
			</div>
			<div class='linksidebar_sub2link' >
				<a class='linksidebar_link' href='../../tutorials/motion/segmenting_ct.html'>Creating surface models</a>
			</div>
			<div class='linksidebar_sub2link' >
				<a class='linksidebar_link' href='../../tutorials/motion/smooth_markers.html'>Smoothing markers</a>
			</div>
			<div class='linksidebar_sub2link_u' >
				<a class='linksidebar_link_u' href='../../tutorials/motion/unification.html'>Rigid body animation</a>
			</div>
			<div class='linksidebar_sublink' >
				<a class='linksidebar_link' href='../../tutorials/mechanisms.html'>Mechanism models</a>
			</div>
			<div class='linksidebar_sublink' >
				<a class='linksidebar_link' href='../../tutorials/stereomorph.html'>StereoMorph User Guide</a>
			</div>
			<div class='linksidebar_sublink' >
				<a class='linksidebar_link' href='../../tutorials/knex/large_u_joint.html'>K'nex models</a>
			</div>
			<div class='linksidebar_mainlink' >
				<a class='linksidebar_link' href='../../contact.html'>Contact</a>
			</div>
			<div class='linksidebar_mainlink' >
				<a class='linksidebar_link' href='../../cv.html'>CV</a>
			</div>
		</div>

		<div id='maincontent' class='maincontent' >

			<div id='pagetrail' class='pagetrail' ><a href="../../about_me.html">home</a>&nbsp;&nbsp;&nbsp;>&nbsp;&nbsp;&nbsp;<a href="../../tutorials/visualization3d.html">tutorials</a>&nbsp;&nbsp;&nbsp;>&nbsp;&nbsp;&nbsp;<a href="../../tutorials/motion.html">motion analysis</a>&nbsp;&nbsp;&nbsp;>&nbsp;&nbsp;&nbsp;rigid body animation</div>


<div class='maincontentfill'>
<h1>Rigid body animation</h1>

<p>
To create a marker-based animation of rigid bodies one needs two types of data. The first 
is a body either with markers fixed to the outside of the body (if using light cameras) or 
markers embedded inside of the body (if using X-ray cameras). The rigid bodies can be simple 
geometric shapes representing rigid elements or full surface meshes, constructed from surface 
or CT scans such as below.
</p>

<div class='p_image_middle_div' style="width:500px;">
	<div><a href='../../img/tutorials/motion/unification bones with markers.jpg' target='_blank'>
		<img width='500px' src='../../img/tutorials/motion/unification bones with markers.jpg' /></a></div>
	<div class='p_image_caption' style='text-align:center;' >
		Four rigid skeletal elements from a channel catfish skull with embedded markers (small metal beads). 
		The surface meshes were created from a CT scan.
	</div>
</div>

<p>
The second type of data is the motion of those markers over time.
</p>

<div class='p_image_middle_div' style="width:500px;">
	<div><a href='../../img/tutorials/motion/unification marker motions.jpg' target='_blank'>
		<img width='500px' src='../../img/tutorials/motion/unification marker motions.jpg' /></a></div>
	<div class='p_image_caption' style='text-align:center;' >
		The corresponding motions of each of the markers in the previous image (colored lines) 
		as measured from stereo X-ray video, with positions at four particular time points indicated by spheres.
	</div>
</div>

<p>
These two data types can then be combined (or "unified") to create a rigid body animation.
At each time point, the marker motion coordinates are used to set the position and orientation of each rigid body
(together these are known as the "pose" of a body).
</p>

<div class='p_image_middle_div' style="width:500px;">
	<div><a href='../../img/tutorials/motion/unification animation bodies and markers.jpg' target='_blank'>
		<img width='500px' src='../../img/tutorials/motion/unification animation bodies and markers.jpg' /></a></div>
	<div class='p_image_caption' style='text-align:center;' >
		After unification the rigid bodies (meshes from a CT scan) are animated using the marker motions. 
		Four time points are shown from an animation of the channel catfish skull, collected from stereo X-ray video.
	</div>
</div>

This tutorial will show you how to unify marked bodies and marker motions to create a rigid body animation.
The uninterrupted block of code can be found at the <a href="#uninterrupted_code">end of this tutorial</a>.
</p><h2>Preliminary steps</h2><p>Make sure that you have 
		<a href="http://rweb.quant.ku.edu/cran/" target="_blank" >R</a> 
		installed on your system (you can find R installation instructions 
		<a href="https://cran.r-project.org" target="_blank" >here</a>).Next, install the beta version (v1.0) of the R package "matools" (not yet on CRAN). 
		You can do this by downloading 
		<a href="https://minhaskamal.github.io/DownGit/#/home?url=https://github.com/aaronolsen/matools" target="_blank" >this folder</a> 
		(< 1MB), unzipping the contents, 
		and then running the commands below to install the package.</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Set the path to where the package was unzipped (customize this to your system)</span>
pkg_path <- <span class="code_quote" >'/Users/aaron/Downloads/matools-master'</span>

<span class="code_comment" ># Run the install.packages function on the matools-master folder</span>
<span class="code_function" >install.packages</span>(<span class="code_quote" >'/Users/aaron/Downloads/matools-master'</span>, repos=NULL, type=<span class="code_quote" >'source'</span>)
</pre></div>

		<p>Alternatively, you can install "matools" using the function <span class='in_line_code'>install_github</span>, from the 
		R package <a href="https://cran.r-project.org/package=devtools" target="_blank" >devtools</a>.</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Load the devtools package (once installed)</span>
<span class="code_function" >library</span>(devtools)

<span class="code_comment" ># Install the version of matools currently on github</span>
<span class="code_function" >install_github</span>(<span class="code_quote" >'aaronolsen/matools'</span>)
</pre></div>

		<p>Once the package is installed, use the <span class='in_line_code'>library</span> function to load the package.</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Load the matools package</span>
<span class="code_function" >library</span>(matools)
</pre></div><h2>Unification</h2>

<p>
For unification you'll first need a set of 3D marker coordinates, either on the surface of or embedded within a marked body or bodies. 
For example, these can be the 3D marker coordinates from a CT or surface scan of the body. 
Since these are not animated they take the form of a simple matrix.
For this tutorial, you can use this <a href='Cat01 landmarks.csv' target='_blank' >landmark coordinates</a> file (as a .csv), 
containing the markers embedded in the channel catfish skull shown in the introduction above.
After downloading the file and moving it to your current R working directory, you can read 
the landmarks using <span class='in_line_code'>readLandmarks</span>.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" >## Unification (solving for body transformations)</span>
<span class="code_comment" ># Read landmark coordinates</span>
landmarks <- readLandmarks(<span class="code_quote" >'Cat01 landmarks.csv'</span>)
</pre></div>

<p>
Next you'll need the positions of these same markers over time in the form of an array (in which the third dimension 
is each frame or time point).
For example, these can be markers tracked and reconstructed using <a href='https://bitbucket.org/xromm/xmalab/wiki/Home' target='_blank' >XMALab</a> 
and exported as a '3D Points' file. 
To produce a smooth animation you can first <a href='smooth_markers.html' >smooth the marker trajectories</a>.
For this tutorial, you can use this 
<a href='Cat01 Trial09 marker motion smoothed.csv' target='_blank' >smoothed 3D marker coordinates</a> file, 
which was created in the <a href='smooth_markers.html' >marker smoothing tutorial</a>. 
This file contains the 3D coordinates of radiopaque markers implanted in a 
channel catfish, collected using <a href='http://xromm.org/' target='_blank' >XROMM</a> 
and tracked using <a href='https://bitbucket.org/xromm/xmalab/wiki/Home' target='_blank' >XMALab</a>. 
After downloading the file and moving it to your current R working directory, you can read 
this file using <span class='in_line_code'>readMotion</span>.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Read smoothed marker motion</span>
read_motion <- <span class="code_function" >readMotion</span>(<span class="code_quote" >'Cat01 Trial09 marker motion smoothed.csv'</span>)
</pre></div>

<p>
It is <strong>essential</strong> that both the landmark and motion coordinates of the markers be at the same scaling. 
So if your motion capture system and scanning software operate on different units, you'll need to convert one of the two so that the units are the same. 
The tutorial datasets used here are both already scaled to the same units (mm).
If you need to change the scaling for your data you can simply multiply <span class='in_line_code'>read_motion$xyz</span> 
by a factor like below.
</p>

<div class="bcode" ><pre class="bcode">
<span class="code_comment" ># Marker motion coordinates can be scaled like this (not needed for tutorial datasets)</span>
read_motion$xyz <- read_motion$xyz * <span class="code_numeric" >10</span>
</pre></div>

<p>
Lastly, it is necessary to specify which markers will be used in animating each rigid body. 
This is done using a <span class='in_line_code'>list</span> object, in which the names of 
each list item correspond to the name of each body and the values of each item are the markers 
to be used for that particular body. 
When listing multiple markers, they should be in a list element named 'align'.
For example, the list below can be used with the tutorial 
landmark and motion files.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Specify which bodies to animate and which markers to use for each body</span>
unify.spec <- <span class="code_function" >list</span>(
	<span class="code_quote" >'Neurocranium'</span>=<span class="code_function" >list</span>(<span class="code_quote" >'align'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'Neurocranium_bead_cau'</span>, <span class="code_quote" >'Neurocranium_bead_cau_e1'</span>, 
		<span class="code_quote" >'Neurocranium_bead_cau_e2'</span>, <span class="code_quote" >'Neurocranium_bead_cra_L'</span>, <span class="code_quote" >'Neurocranium_bead_cra_R'</span>, 
		<span class="code_quote" >'Neurocranium_bead_mid'</span>)),
	<span class="code_quote" >'SuspensoriumL'</span>=<span class="code_function" >list</span>(<span class="code_quote" >'align'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'SuspensoriumL_bead_dor'</span>, <span class="code_quote" >'SuspensoriumL_bead_mid'</span>, 
		<span class="code_quote" >'SuspensoriumL_bead_ven'</span>)),
	<span class="code_quote" >'LowerJawL'</span>=<span class="code_function" >list</span>(<span class="code_quote" >'align'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'LowerJawL_bead_cau'</span>, <span class="code_quote" >'LowerJawL_bead_cra'</span>, <span class="code_quote" >'LowerJawL_bead_mid'</span>)),
	<span class="code_quote" >'OperculumL'</span>=<span class="code_function" >list</span>(<span class="code_quote" >'align'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'OperculumL_bead_cau_dor'</span>, <span class="code_quote" >'OperculumL_bead_cra_dor'</span>, 
		<span class="code_quote" >'OperculumL_bead_ven'</span>))
)
</pre></div>

<p>
Note that the neurocranium has six markers while the rest of the elements all have three markers. 
To solve for the pose of a body in 3D using only markers, the body must have at least three markers 
that are not co-linear (all in a line). Even then, more than three markers is preferable to minimize error.
Further along this tutorial will explain how to animate a body with fewer than three markers, 
however this requires additional information or requires making simplifying assumptions.
</p>

<p>
It's now possible to call the <span class='in_line_code'>unifyMotion</span> function. 
There are three additional parameters to note at this point. The first is 
<span class='in_line_code'>print.progress</span>, which if <span class='in_line_code'>TRUE</span> will print out exactly what 
<span class='in_line_code'>unifyMotion</span> is doing step by step (default is <span class='in_line_code'>FALSE</span>). 
The <span class='in_line_code'>print.progress.iter</span> parameter is the iteration (or iterations) 
for which the step-by-step progress will be printed (default is 1). Note that the errors that are printed to the 
console as a part of <span class='in_line_code'>print.progress</span> are only the errors for that particular iteration, not 
the entire sequence. Lastly, the <span class='in_line_code'>plot.diag</span> can be used to 
create a plot showing the unification errors (how well the corresponding marker sets align with each other) 
over the entire animation sequence (default is NULL). The code below will create a pdf 
named 'Unification errors.pdf'.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Unify landmarks and motion to create an animation</span>
unify_motion <- <span class="code_function" >unifyMotion</span>(read_motion, xyz.mat=landmarks, unify.spec=unify.spec, 
	print.progress=TRUE, print.progress.iter=<span class="code_numeric" >1</span>, plot.diag=<span class="code_quote" >'Unification errors.pdf'</span>)
</pre></div>

<p>
The <span class='in_line_code'>unifyMotion</span> function returns two objects, a 'motion' object 
(<span class='in_line_code'>unify_motion$motion</span>) and an error matrix (<span class='in_line_code'>unify_motion$error</span>). 
A first thing to do after running <span class='in_line_code'>unifyMotion$motion</span> is 
to check the unification errors using the <span class='in_line_code'>print</span> command.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Check the unification errors</span>
<span class="code_function" >print</span>(unify_motion$error)
</pre></div>

<p>
This will print the error for each body for the first five iterations and then summary statistics for all iterations (min, max, and mean).
</p>

<div class="bcode" ><pre class="bcode">
     $LowerJawL $Neurocranium $OperculumL $SuspensoriumL
<span class="code_numeric" >1</span>    <span class="code_numeric" >0.02293696</span>    <span class="code_numeric" >0.09415792</span>  <span class="code_numeric" >0.05953781</span>     <span class="code_numeric" >0.09642377</span>
<span class="code_numeric" >2</span>    <span class="code_numeric" >0.01589944</span>    <span class="code_numeric" >0.09062001</span>  <span class="code_numeric" >0.05473783</span>     <span class="code_numeric" >0.09440632</span>
<span class="code_numeric" >3</span>    <span class="code_numeric" >0.01623216</span>    <span class="code_numeric" >0.08753566</span>  <span class="code_numeric" >0.05061602</span>     <span class="code_numeric" >0.09254273</span>
<span class="code_numeric" >4</span>    <span class="code_numeric" >0.01828475</span>    <span class="code_numeric" >0.08490102</span>  <span class="code_numeric" >0.04720247</span>     <span class="code_numeric" >0.09081870</span>
<span class="code_numeric" >5</span>    <span class="code_numeric" >0.01918041</span>    <span class="code_numeric" >0.08268930</span>  <span class="code_numeric" >0.04437062</span>     <span class="code_numeric" >0.08927868</span>
... and <span class="code_numeric" >1814</span> more rows
     $LowerJawL $Neurocranium $OperculumL $SuspensoriumL
min     <span class="code_numeric" >0.00665</span>       <span class="code_numeric" >0.03968</span>     <span class="code_numeric" >0.00129</span>        <span class="code_numeric" >0.01347</span>
max     <span class="code_numeric" >0.28014</span>       <span class="code_numeric" >0.19107</span>     <span class="code_numeric" >0.12133</span>        <span class="code_numeric" >0.31113</span>
mean    <span class="code_numeric" >0.05060</span>       <span class="code_numeric" >0.09436</span>     <span class="code_numeric" >0.03758</span>        <span class="code_numeric" >0.09758</span>
</pre></div>

<p>
These errors are the error after aligning the marker landmarks with the markers from the motion data. 
If a body were perfectly rigid (i.e. no bending, stretching, etc.) and if the marker motions were collected with perfect accuracy 
the unification errors would be zero. However, deformation of the body and errors in motion capture will inevitably lead to some unification errors. 
In this case the errors do not exceed 0.31 mm (310 microns), which amounts to 1% or less of 
the total length of the bodies we are animating.
</p>

<p>
Of course another next step after unification is to create an actual animation to visualize the motion of the bodies. 
The key piece to creating an animation is returned from <span class='in_line_code'>unifyMotion</span> as a part of the 
'motion' object, specifically <span class='in_line_code'>unify_motion$motion$tmat</span>, 
which is an array containing a transformation matrix for each element at each iteration.
The next section will show how to use this 'tmat' object and the R package 
<a href='https://cran.r-project.org/package=svgViewR' target='_blank'>svgViewR</a> to create an animation.
</p>

<h2>Creating an animation</h2>

<p>
To create a rigid body animation in R, we'll use the R package <a href='https://cran.r-project.org/package=svgViewR' target='_blank'>svgViewR</a>. 
This package creates interactive animations as standalone html files using the <a href='https://threejs.org/' target='_blank'>threejs javascript library</a>.
</p>

<a href='../../viz/tutorials/motion/Rigid body animation.html' target='_blank' >
	<img width='500px' class='center' style='border:1px black' src='../../img/tutorials/motion/unification rigid body animation screenshot.jpg' />
</a>
<div class='img_caption' >
	Interactive animation file created using <a href='https://cran.r-project.org/package=svgViewR' target='_blank'>svgViewR</a>.
</div>

<p>
Creating an svgViewR visualization uses a similar approach to plotting to pdf or image files in R. 
Start by declaring a new file using the <span class='in_line_code'>svg.new</span> function, including 
where you would like to save the file and the name you would like to give it.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" >## Create an animation</span>
<span class="code_comment" ># Declare a new visualization file</span>
<span class="code_function" >svg.new</span>(file=<span class="code_quote" >'Rigid body animation.html'</span>, mode=<span class="code_quote" >'webgl'</span>)
</pre></div>

<p>
Next add the surface models for each body and markers to the "scene". 
If you're using the tutorial files you can download the surface mesh files for each of the 
skeletal elements as a compressed folder <a href='meshes.zip' target='_blank' >here</a>.
</p>

<p>
The easiest way to add each element is to loop through the names of the unify parameters list <span class='in_line_code'>unify.spec</span>. 
To add a surface mesh to the scene use the <span class='in_line_code'>svg.mesh</span> function (note that currently this only works with OBJ surface models). 
To create the animation we are going to <i>transform</i> these surface models using the transformation matrices output from <span class='in_line_code'>unifyMotion</span>. 
But in order to known which model is which we have to specify a name for each mesh. 
This is done using the <span class='in_line_code'>name</span> parameter in the <span class='in_line_code'>svg.mesh</span> function.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># For each body in unify.spec names</span>
<span class="code_function" >for</span>(body_name in <span class="code_function" >names</span>(unify.spec)){

	<span class="code_comment" ># Add surface mesh (OBJ) of body</span>
	<span class="code_function" >svg.mesh</span>(file=<span class="code_function" >paste0</span>(<span class="code_quote" >'meshes/Cat 01 '</span>, body_name, <span class="code_quote" >'.obj'</span>), name=body_name)
	
	<span class="code_comment" ># Find markers corresponding to body using regular expression matching</span>
	markers_match <- <span class="code_function" >grepl</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'^'</span>, body_name, <span class="code_quote" >'_'</span>), <span class="code_function" >dimnames</span>(read_motion$xyz)[[<span class="code_numeric" >1</span>]])

	<span class="code_comment" ># Get marker names from first dimension of xyz motion coordinates</span>
	body_markers <- <span class="code_function" >dimnames</span>(read_motion$xyz)[[<span class="code_numeric" >1</span>]][markers_match]

	<span class="code_comment" ># Plot markers from motion capture (already animated)</span>
	<span class="code_function" >svg.spheres</span>(x=read_motion$xyz[body_markers,,], col=<span class="code_quote" >'yellow'</span>)

	<span class="code_comment" ># Plot markers as landmarks (static matrix to be transformed)</span>
	<span class="code_function" >svg.spheres</span>(x=landmarks[body_markers,], col=<span class="code_quote" >'gray'</span>, name=body_name)
}
</pre></div>

<p>
To add markers to the scene we can add spheres using the <span class='in_line_code'>svg.sphere</span> function. 
To find the markers corresponding to each body I've used a simple regular expression 
search on the names of the markers (using the <a href='https://stat.ethz.ch/R-manual/R-devel/library/base/html/grep.html' target='_blank'>grepl</a> function). 
For this study, each marker name begins with the body with which it is associated followed by an underscore. 
So the markers associated with each body can be found by pasting the body name between the '^' symbol (indicating the start of the string) and an underscore.
</p>

<p>
Additionally note that above I've added two different types of markers to the scene. 
I added the first markers using <span class='in_line_code'>read_motion$xyz[body_markers,,]</span>. 
These are the marker motion coordinates (obtained from the motion capture system) in the form of a three-dimensional array, 
where the last dimension corresponds to each frame. 
The second markers that I added, <span class='in_line_code'>landmarks[body_markers,]</span>, are the markers from the landmark matrix. 
These are static marker coordinates but they can be animated (i.e. transformed) just like the surface models. 
To transform these markers, the corresponding body name needs to be specified along with the markers just as for the meshes. 
I used 'yellow' for the x-ray motion capture coordinates to help remember which is which (yellow being the background color of the radioactive symbol).
</p>

<p>
To transform the surface meshes and markers in the scene, use the <span class='in_line_code'>svg.transform</span> function. 
The transformation object from <span class='in_line_code'>unify_motion$motion</span> can be passed directly to the 
<span class='in_line_code'>tmarr</span> parameter.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Apply transformations to any plotted objects with names matching elements</span>
<span class="code_function" >svg.transform</span>(tmarr=unify_motion$motion$tmat, times=read_motion$time)
</pre></div>

<p>
The body names are contained within the 'tmat' object (as the names of the 3rd dimension) so they will be 
automatically read by the function. If the names are not present or if the names are dropped, 
they can also be entered using the <span class='in_line_code'>applyto</span> parameter). 
Additionally, the time (in seconds) corresponding to each iteration 
must be passed in through the <span class='in_line_code'>times</span> parameter. The times corresponding 
to each frame are contained in the original motion file. 
Entering the times allows the animation renderer to faithfully reproduce the motion at a specified rate.
</p>

<p>
If desired, a coordinate system can be added around all objects currently in the scene using 
<span class='in_line_code'>svg.frame()</span>.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Add a coordinate system around all drawn objects</span>
frame <- <span class="code_function" >svg.frame</span>()
</pre></div>

<p>
And lastly, close the connection to the visualization file using <span class='in_line_code'>svg.close()</span>. 
This finishes writing the visualization file and prevents further objects from being added to it 
(analogous to the <a href='https://stat.ethz.ch/R-manual/R-devel/library/grDevices/html/dev.html' target='_blank'>dev.off</a> function).
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Close the file connection</span>
<span class="code_function" >svg.close</span>()
</pre></div>

<p>
This should create the visualization shown below that can be opened in most major web browsers (currently works best in Chrome or Safari). 
Note that this is a standalone html file containing all of the code and mesh data needed for the visualization so 
it can be moved, e-mailed, etc. R is only needed to create the file, not to open it. 
The timeline along the bottom of the browser window has tools for controlling the animation playback, including the speed (far right). 
The animation is played back at realtime by default and this can be slowed down (<1) or sped up (>1) as needed.
</p>

<a href='../../viz/tutorials/motion/Rigid body animation.html' target='_blank' >
<video style='display: block;margin: 0 auto; width: 550px;' controls>
  <source src='../../viz/tutorials/motion/unification rigid body animation.mp4' type='video/mp4'>
Your browser does not support the video tag.
</video>
</a>
<div class='img_caption' >
	Interactive rigid body animation created using <a href='https://cran.r-project.org/package=svgViewR' target='_blank'>svgViewR</a>.
</div>

<p>
From the animation you can see that the gray and yellow markers (the transformed landmarks and the motion capture coordinates, respectively) 
line up pretty well but not perfectly. This is what is expected when the unification errors are low because the two marker sets align well. 
Additionally, you'll notice how one skeletal element in particular, the suspensorium or "cheek bone" of the fish, is "wobbling". 
This is because all of the markers associated with that element are nearly co-linear and there is not enough information to fully "constrain" the motion of that element. 
Thus it tends to wobble about an axis defined by those nearly co-linear markers. 
We'll see further along in this tutorial how to reduce this wobble using "virtual points".
</p>

<h2>Using regular expressions in unify specifications</h2>

<p>
When we have lots of markers it gets a bit cumbersome to list the name of each marker in <span class='in_line_code'>unify.spec</span>. 
If the markers are labeled according to a consistent naming scheme then it's much simpler to use regular expressions. 
For example, the marker names in the tutorial dataset all begin with the body with which they're associated followed by an underscore and the word 'bead'. 
Thus, it's possible to re-write <span class='in_line_code'>unify.spec</span> as follows 
(since just a single regular expression is listed per body, the 'align' list can be omitted).
</p>

<div class="code" ><pre class="code">
<span class="code_comment" >## Using regular expressions in unify specifications</span>
<span class="code_comment" ># Specify which bodies to animate and which markers to use for each body</span>
unify.spec <- <span class="code_function" >list</span>(
	<span class="code_quote" >'Neurocranium'</span>=<span class="code_quote" >'^Neurocranium_bead'</span>,
	<span class="code_quote" >'SuspensoriumL'</span>=<span class="code_quote" >'^SuspensoriumL_bead'</span>,
	<span class="code_quote" >'LowerJawL'</span>=<span class="code_quote" >'^LowerJawL_bead'</span>,
	<span class="code_quote" >'OperculumL'</span>=<span class="code_quote" >'^OperculumL_bead'</span>
)
</pre></div>

<p>
Then run <span class='in_line_code'>unifyMotion</span> with the <span class='in_line_code'>regexp</span> parameter set to <span class='in_line_code'>TRUE</span> (default is <span class='in_line_code'>FALSE</span>).
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Run unifyMotion with regexp to TRUE to use regular expressions in unify.spec</span>
unify_motion <- <span class="code_function" >unifyMotion</span>(read_motion, xyz.mat=landmarks, unify.spec=unify.spec, 
	regexp=TRUE, plot.diag=<span class="code_quote" >'Unify.pdf'</span>)
</pre></div>


<h2>Saving the results for further analysis and export</h2>

<p>
There are a couple ways to save the results of unifyMotion. The first is to save the entire 
motion object using the <span class='in_line_code'>writeMotion</span> function.
The motion object output by <span class='in_line_code'>unifyMotion</span> is exactly the same 
as the motion object that was put into the function only with the new body transformations added to it (as 'tmat'). 
It is best to save the whole motion object because this retains any metadata that have been added 
to the motion object (trial name, times, frame numbers, etc.).
</p>

<div class="code" ><pre class="code">
<span class="code_comment" >## Saving the results</span>
<span class="code_comment" ># Save motion</span>
<span class="code_function" >writeMotion</span>(x=unify_motion$motion, file=<span class="code_quote" >'Cat01 Trial09 body motion smoothed.csv'</span>)
</pre></div>

<p>
This saved motion file can be then be read by using <span class='in_line_code'>readMotion</span>.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Read saved motion</span>
read_saved_motion <- <span class="code_function" >readMotion</span>(file=<span class="code_quote" >'Cat01 Trial09 body motion smoothed.csv'</span>)
</pre></div>

<p>
A second way to save the unification results is to just save the rigid body transformations. 
This is useful if you want to use the transformations in another program 
(such as to <a href='https://wiki.brown.edu/confluence/display/ctx/Animate+Bones+in+Maya' target='_blank'>create an animation using Maya</a>). 
To save only the rigid body transformations, use <span class='in_line_code'>writeMotion</span> 
but just including the 'tmat' object as shown below.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Save just the transformations</span>
<span class="code_function" >writeMotion</span>(x=<span class="code_function" >list</span>(<span class="code_quote" >'tmat'</span>=unify_motion$motion$tmat), file=<span class="code_quote" >'Cat01 Trial09 body tmat smoothed.csv'</span>)
</pre></div>

<p>
Lastly, since the unification errors are a matrix they can be saved simply by using the 
utils function <span class='in_line_code'>write.csv</span> function.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Save the unification errors</span>
<span class="code_function" >write.csv</span>(x=unify_motion$error, file=<span class="code_quote" >'Unification errors.csv'</span>)
</pre></div>

<h2>Visualizing motion relative to a particular body</h2>

<p>
When visually inspecting the results of unifyMotion it's often useful to fix the motion of one body. 
For example, with this tutorial dataset the catfish is swimming around the tank which makes it hard to 
see the motions of the skeletal elements in head.
To get the motion of the elements relative to a particular body you can use the 
<span class='in_line_code'>relativeMotion</span> function. 
Input the motion object, which now includes the rigid body transformations, and the body that you would like to fix.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" >## Create animation of motion relative to neurocranium</span>
<span class="code_comment" ># Get relative motion</span>
relative_motion <- <span class="code_function" >relativeMotion</span>(motion=unify_motion$motion, fixed=<span class="code_quote" >'Neurocranium'</span>)
</pre></div>

<p>
The <span class='in_line_code'>relativeMotion</span> function outputs a new motion object in 
which all motions are relative to a fixed neurocranium. 
To create a new animation, simply re-run the code above but replacing the previous motion objects with <span class='in_line_code'>relative_motion</span>, as shown below.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Create animation with fixed neurocranium</span>
<span class="code_function" >svg.new</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'Animation fixed Neurocranium.html'</span>), mode=<span class="code_quote" >'webgl'</span>)
<span class="code_function" >for</span>(body_name in <span class="code_function" >names</span>(unify.spec)){
	<span class="code_function" >svg.mesh</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'meshes/Cat 01 '</span>, body_name, <span class="code_quote" >'.obj'</span>), name=body_name)
	markers_match <- <span class="code_function" >grepl</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'^'</span>, body_name, <span class="code_quote" >'_'</span>), <span class="code_function" >dimnames</span>(relative_motion$xyz)[[<span class="code_numeric" >1</span>]])
	body_markers <- <span class="code_function" >dimnames</span>(relative_motion$xyz)[[<span class="code_numeric" >1</span>]][markers_match]
	<span class="code_function" >svg.spheres</span>(relative_motion$xyz[body_markers,,], col=<span class="code_quote" >'yellow'</span>)
}
<span class="code_function" >svg.transform</span>(relative_motion$tmat, times=relative_motion$time)
frame <- <span class="code_function" >svg.frame</span>()
<span class="code_function" >svg.close</span>()
</pre></div>

<a href='../../viz/tutorials/motion/Animation fixed Neurocranium.html' target='_blank' >
<video style='display: block;margin: 0 auto; width: 550px;' controls>
  <source src='../../viz/tutorials/motion/unification animation fixed neurocranium.mp4' type='video/mp4'>
Your browser does not support the video tag.
</video>
</a>
<div class='img_caption' >
	Rigid body animation showing motion relative to a fixed neurocranium.
</div>


<h2>Constraining body motion using "Virtual points"</h2>

<p>
You may have noticed (particularly in the preceding video with motion relative to the neurocranium) 
that the suspensorium or "cheek bone" of the fish, is "wobbling". 
This is because all of the markers associated with that element are nearly co-linear, causing the element to 
wobble about an axis defined by those nearly co-linear markers. 
To reduce this wobble we can add in extra landmarks (referred to as "virtual points" or 
"virtual markers") where we know that there is little motion of the element 
to help constrain the motion.
</p>

<p>
The suspensorium in catfish is attached to the neurocranium along a broad, hinge-like joint. 
One particular part of the joint has a tough ligament tethering the suspensorium to the neurocranium, preventing translation at that point and 
presenting an ideal virtual point to constrain the motion of the suspensorium (shown in the image below).
</p>

<div class='p_image_middle_div' style="width:400px;">
	<div><a href='../../viz/tutorials/motion/Suspensorium virtual point.html' target='_blank'>
		<img width='400px' src='../../img/tutorials/motion/unification suspensorium virtual point.jpg' /></a></div>
	<div class='p_image_caption' style='text-align:center;' >
		A virtual point (indicated by the red sphere) located at a ligamentous joint between the suspensorium and neurocranium 
		can be added to supplement the markers and constrain the motion of the element. Click image to open interactive visualization.
	</div>
</div>

<p>
For the interested user, the visualization pictured above can be created using the following code:
</p>

<div class="code" ><pre class="code">
<span class="code_comment" >## Constraining body motion using virtual points</span>
<span class="code_comment" ># Create visual of virtual point</span>
<span class="code_function" >svg.new</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'Suspensorium virtual point.html'</span>), mode=<span class="code_quote" >'webgl'</span>)
<span class="code_function" >for</span>(body_name in <span class="code_function" >c</span>(<span class="code_quote" >'Neurocranium'</span>, <span class="code_quote" >'SuspensoriumL'</span>)){
	<span class="code_function" >svg.mesh</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'meshes/Cat 01 '</span>, body_name, <span class="code_quote" >'.obj'</span>), opacity=<span class="code_numeric" >0.5</span>)
	markers_match <- <span class="code_function" >grepl</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'^'</span>, body_name, <span class="code_quote" >'_'</span>), <span class="code_function" >dimnames</span>(read_motion$xyz)[[<span class="code_numeric" >1</span>]])
	body_markers <- <span class="code_function" >dimnames</span>(read_motion$xyz)[[<span class="code_numeric" >1</span>]][markers_match]
	<span class="code_function" >svg.spheres</span>(landmarks[body_markers,], col=<span class="code_quote" >'gray'</span>)
}
<span class="code_function" >svg.spheres</span>(landmarks[<span class="code_quote" >'Neurocranium-SuspensoriumL_nc_susp_jt_cra'</span>,], col=<span class="code_quote" >'red'</span>)
<span class="code_function" >svg.close</span>()
</pre></div>

<p>
To use a virtual point during the unification step set the 3D coordinate of the virtual point 
(in the same coordinate system as the surface meshes) and add this to the marker landmarks file. 
I like to get virtual point coordinates in <a href='https://www.blender.org/' target='_blank'>Blender</a> by 
<a href='https://docs.blender.org/manual/en/latest/modeling/curves/selecting.html' target='_blank'>selecting a vertex on the mesh</a> 
and then getting the vertex XYZ coordinate from the right-side panel (see below).
</p>

<div class='p_image_middle_div' style="width:550px;">
	<div><a href='../../img/tutorials/motion/unification blender get vertex coordinate.jpg' target='_blank'>
		<img width='550px' src='../../img/tutorials/motion/unification blender get vertex coordinate.jpg' /></a></div>
	<div class='p_image_caption' style='text-align:center;' >
		<a href='https://www.blender.org/' target='_blank'>Blender</a> can be used to get the 3D coordinate of 
		a point on a mesh. The XYZ coordinate is shown near the top right corner under 'Transform'. 
		Be sure that 'Local' is selected.
	</div>
</div>

<p>
For the tutorial dataset this virtual point is labeled 'Neurocranium-SuspensoriumL_nc_susp_jt_cra' in 
the <span class='in_line_code'>landmarks</span> matrix. 
This virtual point will be animated with the neurocranium and then used to constrain the motion of the suspensorium. 
</p>

<p>
To use the virtual point we just have to amend the <span class='in_line_code'>unify.spec</span> list. 
Under <span class='in_line_code'>SuspensoriumL</span> add a new list with two labeled items: 'align' and 'point'. 
The markers that will be used for the alignment (i.e. the markers we've been using so far) go under 'align' (this is the default). 
Then list any virtual points after 'point' in a named list, where the name of each virtual 
point group is the body used to animate the virtual point. 
In this case the name of the virtual point group is 'Neurocranium' since the virtual point is animated with the neurocranium.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Add virtual point to unify specifications</span>
unify.spec <- <span class="code_function" >list</span>(
	<span class="code_quote" >'Neurocranium'</span>=<span class="code_quote" >'^Neurocranium'</span>,
	<span class="code_quote" >'SuspensoriumL'</span>=<span class="code_function" >list</span>(
		<span class="code_quote" >'align'</span>=<span class="code_quote" >'^SuspensoriumL'</span>,
		<span class="code_quote" >'point'</span>=<span class="code_function" >list</span>(<span class="code_quote" >'Neurocranium'</span>=<span class="code_quote" >'Neurocranium-SuspensoriumL_nc_susp_jt_cra'</span>)),
	<span class="code_quote" >'LowerJawL'</span>=<span class="code_quote" >'^LowerJawL'</span>,
	<span class="code_quote" >'OperculumL'</span>=<span class="code_quote" >'^OperculumL'</span>
)
</pre></div>

<p>
You can use as many virtual points as you'd like. 
For example, <span class='in_line_code'>unify.spec</span> for more than one virtual point animated with a body would be:
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Multiple virtual points</span>
unify_spec2 <- <span class="code_function" >list</span>(
	<span class="code_quote" >'Body1'</span>=<span class="code_quote" >'^Body1'</span>,
	<span class="code_quote" >'Body2'</span>=<span class="code_function" >list</span>(
		<span class="code_quote" >'align'</span>=<span class="code_quote" >'^Body2'</span>,
		<span class="code_quote" >'point'</span>=<span class="code_function" >list</span>(<span class="code_quote" >'Body1'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'Body1VirtualPoint1'</span>, <span class="code_quote" >'Body1VirtualPoint2'</span>)))
)
</pre></div>

<p>
You can also use virtual points associated with multiple bodies. For example, <span class='in_line_code'>unify.spec</span> for multiple 
virtual points animated with multiple bodies would be as follows:
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Multiple virtual points</span>
unify_spec3 <- <span class="code_function" >list</span>(
	<span class="code_quote" >'Body1'</span>=<span class="code_quote" >'^Body1'</span>,
	<span class="code_quote" >'Body2'</span>=<span class="code_quote" >'^Body2'</span>,
	<span class="code_quote" >'Body3'</span>=<span class="code_function" >list</span>(
		<span class="code_quote" >'align'</span>=<span class="code_quote" >'^Body3'</span>,
		<span class="code_quote" >'point'</span>=<span class="code_function" >list</span>(
			<span class="code_quote" >'Body1'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'Body1VirtualPoint1'</span>, <span class="code_quote" >'Body1VirtualPoint2'</span>)),
			<span class="code_quote" >'Body2'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'Body2VirtualPoint1'</span>, <span class="code_quote" >'Body2VirtualPoint2'</span>))
)
</pre></div>

<p>
If regexp is <span class='in_line_code'>TRUE</span> the virtual point names will be matched using regular expressions, just like the align points.
</p>

<p>
Importantly, <span class='in_line_code'>unifyMotion</span> does <strong>not</strong> treat virtual points 
in the same way as the markers or "align" points.
Instead the function first finds the pose of the body using only the align points, an axis is fit to the align points at each iteration, 
and the body is rotated about this axis to minimize the distance between the virtual points 
animated with the parent body (here, the neurocranium) and the dependent body (here, the suspensorium). 
In this way the virtual points will not "pull" the body away from the markers but merely rotate the body around them. 
This has the effect of weighting the align markers more heavily than the virtual points 
(which is what we want since we know the align markers with more certainty than the virtual points). 
When the align markers are nearly co-linear a virtual point supplies additional information, 
based on known (anatomical) constraints, to constrain the motion about the axis with the most 
uncertainty while not compromising the reconstructed motion where there is more certainty.  
The <span class='in_line_code'>unifyMotion</span> function will automatically determine the 
order in which to solve for the body transformations given a particular hierarchy of virtual points so 
the order in which you list the bodies and virtual points in <span class='in_line_code'>unify.spec</span> doesn't matter.
</p>

<p>
After updating the unify specifications, call <span class='in_line_code'>unifyMotion</span> again.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Unify motion using a virtual point</span>
unify_motion <- <span class="code_function" >unifyMotion</span>(read_motion, xyz.mat=landmarks, unify.spec=unify.spec, 
	regexp=TRUE, plot.diag=<span class="code_quote" >'Unify.pdf'</span>)
</pre></div>

<p>
To visualize the results, create a new animation, adding a red sphere to indicate the new virtual point 
and reducing the opacity of the bones so that the virtual point is visible.
</p>

<div class="code" ><pre class="code">
<span class="code_comment" ># Get motion relative to the neurocranium</span>
relative_motion <- <span class="code_function" >relativeMotion</span>(unify_motion$motion, fixed=<span class="code_quote" >'Neurocranium'</span>)

<span class="code_comment" ># Create an animation with the virtual point</span>
<span class="code_function" >svg.new</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'Animation virtual fixed Neurocranium.html'</span>), mode=<span class="code_quote" >'webgl'</span>)
<span class="code_function" >for</span>(body_name in <span class="code_function" >names</span>(unify.spec)){
	<span class="code_function" >svg.mesh</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'meshes/Cat 01 '</span>, body_name, <span class="code_quote" >'.obj'</span>), name=body_name, opacity=<span class="code_numeric" >0.7</span>)
	markers_match <- <span class="code_function" >grepl</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'^'</span>, body_name, <span class="code_quote" >'_'</span>), <span class="code_function" >dimnames</span>(relative_motion$xyz)[[<span class="code_numeric" >1</span>]])
	body_markers <- <span class="code_function" >dimnames</span>(relative_motion$xyz)[[<span class="code_numeric" >1</span>]][markers_match]
	<span class="code_function" >svg.spheres</span>(relative_motion$xyz[body_markers,,], col=<span class="code_quote" >'yellow'</span>)
}
<span class="code_function" >svg.spheres</span>(landmarks[<span class="code_quote" >'Neurocranium-SuspensoriumL_nc_susp_jt_cra'</span>,], col=<span class="code_quote" >'red'</span>, name=<span class="code_quote" >'Neurocranium'</span>)
<span class="code_function" >svg.transform</span>(relative_motion$tmat, times=relative_motion$time)
frame <- <span class="code_function" >svg.frame</span>()
<span class="code_function" >svg.close</span>()
</pre></div>

<p>
The addition of a single virtual point eliminates most of the previous wobbling.
</p>

<a href='../../viz/tutorials/motion/Animation virtual fixed Neurocranium.html' target='_blank' >
<video style='display: block;margin: 0 auto; width: 550px;' controls>
  <source src='../../viz/tutorials/motion/unification animation fixed neurocranium virtual.mp4' type='video/mp4'>
Your browser does not support the video tag.
</video>
</a>
<div class='img_caption' >
	Rigid body animation of motion relative to a fixed neurocranium. A virtual point (red) animated with the neurocranium has been used 
	to constrain the motion of the suspensorium, removing most of the wobble present when just using the motion capture markers ('yellow'). 
	Click video to open interactive visualization.
</div>

<br />
</div><h2>Uninterrupted code</h2><a name="uninterrupted_code" ></a><br /><div class="code" ><pre class="code">
<span class="code_comment" ># Set the path to where the package was unzipped (customize this to your system)</span>
pkg_path <- <span class="code_quote" >'/Users/aaron/Downloads/matools-master'</span>

<span class="code_comment" ># Run the install.packages function on the matools-master folder</span>
<span class="code_function" >install.packages</span>(<span class="code_quote" >'/Users/aaron/Downloads/matools-master'</span>, repos=NULL, type=<span class="code_quote" >'source'</span>)

<span class="code_comment" ># Load the devtools package (once installed)</span>
<span class="code_function" >library</span>(devtools)

<span class="code_comment" ># Install the version of matools currently on github</span>
<span class="code_function" >install_github</span>(<span class="code_quote" >'aaronolsen/matools'</span>)

<span class="code_comment" ># Load the matools package</span>
<span class="code_function" >library</span>(matools)

<span class="code_comment" >## Unification (solving for body transformations)</span>
<span class="code_comment" ># Read landmark coordinates</span>
landmarks <- readLandmarks(<span class="code_quote" >'Cat01 landmarks.csv'</span>)

<span class="code_comment" ># Read smoothed marker motion</span>
read_motion <- <span class="code_function" >readMotion</span>(<span class="code_quote" >'Cat01 Trial09 marker motion smoothed.csv'</span>)

<span class="code_comment" ># Specify which bodies to animate and which markers to use for each body</span>
unify.spec <- <span class="code_function" >list</span>(
	<span class="code_quote" >'Neurocranium'</span>=<span class="code_function" >list</span>(<span class="code_quote" >'align'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'Neurocranium_bead_cau'</span>, <span class="code_quote" >'Neurocranium_bead_cau_e1'</span>, 
		<span class="code_quote" >'Neurocranium_bead_cau_e2'</span>, <span class="code_quote" >'Neurocranium_bead_cra_L'</span>, <span class="code_quote" >'Neurocranium_bead_cra_R'</span>, 
		<span class="code_quote" >'Neurocranium_bead_mid'</span>)),
	<span class="code_quote" >'SuspensoriumL'</span>=<span class="code_function" >list</span>(<span class="code_quote" >'align'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'SuspensoriumL_bead_dor'</span>, <span class="code_quote" >'SuspensoriumL_bead_mid'</span>, 
		<span class="code_quote" >'SuspensoriumL_bead_ven'</span>)),
	<span class="code_quote" >'LowerJawL'</span>=<span class="code_function" >list</span>(<span class="code_quote" >'align'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'LowerJawL_bead_cau'</span>, <span class="code_quote" >'LowerJawL_bead_cra'</span>, <span class="code_quote" >'LowerJawL_bead_mid'</span>)),
	<span class="code_quote" >'OperculumL'</span>=<span class="code_function" >list</span>(<span class="code_quote" >'align'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'OperculumL_bead_cau_dor'</span>, <span class="code_quote" >'OperculumL_bead_cra_dor'</span>, 
		<span class="code_quote" >'OperculumL_bead_ven'</span>))
)

<span class="code_comment" ># Unify landmarks and motion to create an animation</span>
unify_motion <- <span class="code_function" >unifyMotion</span>(read_motion, xyz.mat=landmarks, unify.spec=unify.spec, 
	print.progress=TRUE, print.progress.iter=<span class="code_numeric" >1</span>, plot.diag=<span class="code_quote" >'Unification errors.pdf'</span>)

<span class="code_comment" ># Check the unification errors</span>
<span class="code_function" >print</span>(unify_motion$error)

<span class="code_comment" >## Create an animation</span>
<span class="code_comment" ># Declare a new visualization file</span>
<span class="code_function" >svg.new</span>(file=<span class="code_quote" >'Rigid body animation.html'</span>, mode=<span class="code_quote" >'webgl'</span>)

<span class="code_comment" ># For each body in unify.spec names</span>
<span class="code_function" >for</span>(body_name in <span class="code_function" >names</span>(unify.spec)){

	<span class="code_comment" ># Add surface mesh (OBJ) of body</span>
	<span class="code_function" >svg.mesh</span>(file=<span class="code_function" >paste0</span>(<span class="code_quote" >'meshes/Cat 01 '</span>, body_name, <span class="code_quote" >'.obj'</span>), name=body_name)
	
	<span class="code_comment" ># Find markers corresponding to body using regular expression matching</span>
	markers_match <- <span class="code_function" >grepl</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'^'</span>, body_name, <span class="code_quote" >'_'</span>), <span class="code_function" >dimnames</span>(read_motion$xyz)[[<span class="code_numeric" >1</span>]])

	<span class="code_comment" ># Get marker names from first dimension of xyz motion coordinates</span>
	body_markers <- <span class="code_function" >dimnames</span>(read_motion$xyz)[[<span class="code_numeric" >1</span>]][markers_match]

	<span class="code_comment" ># Plot markers from motion capture (already animated)</span>
	<span class="code_function" >svg.spheres</span>(x=read_motion$xyz[body_markers,,], col=<span class="code_quote" >'yellow'</span>)

	<span class="code_comment" ># Plot markers as landmarks (static matrix to be transformed)</span>
	<span class="code_function" >svg.spheres</span>(x=landmarks[body_markers,], col=<span class="code_quote" >'gray'</span>, name=body_name)
}

<span class="code_comment" ># Apply transformations to any plotted objects with names matching elements</span>
<span class="code_function" >svg.transform</span>(tmarr=unify_motion$motion$tmat, times=read_motion$time)

<span class="code_comment" ># Add a coordinate system around all drawn objects</span>
frame <- <span class="code_function" >svg.frame</span>()

<span class="code_comment" ># Close the file connection</span>
<span class="code_function" >svg.close</span>()

<span class="code_comment" >## Using regular expressions in unify specifications</span>
<span class="code_comment" ># Specify which bodies to animate and which markers to use for each body</span>
unify.spec <- <span class="code_function" >list</span>(
	<span class="code_quote" >'Neurocranium'</span>=<span class="code_quote" >'^Neurocranium_bead'</span>,
	<span class="code_quote" >'SuspensoriumL'</span>=<span class="code_quote" >'^SuspensoriumL_bead'</span>,
	<span class="code_quote" >'LowerJawL'</span>=<span class="code_quote" >'^LowerJawL_bead'</span>,
	<span class="code_quote" >'OperculumL'</span>=<span class="code_quote" >'^OperculumL_bead'</span>
)

<span class="code_comment" ># Run unifyMotion with regexp to TRUE to use regular expressions in unify.spec</span>
unify_motion <- <span class="code_function" >unifyMotion</span>(read_motion, xyz.mat=landmarks, unify.spec=unify.spec, 
	regexp=TRUE, plot.diag=<span class="code_quote" >'Unify.pdf'</span>)

<span class="code_comment" >## Saving the results</span>
<span class="code_comment" ># Save motion</span>
<span class="code_function" >writeMotion</span>(x=unify_motion$motion, file=<span class="code_quote" >'Cat01 Trial09 body motion smoothed.csv'</span>)

<span class="code_comment" ># Read saved motion</span>
read_saved_motion <- <span class="code_function" >readMotion</span>(file=<span class="code_quote" >'Cat01 Trial09 body motion smoothed.csv'</span>)

<span class="code_comment" ># Save just the transformations</span>
<span class="code_function" >writeMotion</span>(x=<span class="code_function" >list</span>(<span class="code_quote" >'tmat'</span>=unify_motion$motion$tmat), file=<span class="code_quote" >'Cat01 Trial09 body tmat smoothed.csv'</span>)

<span class="code_comment" ># Save the unification errors</span>
<span class="code_function" >write.csv</span>(x=unify_motion$error, file=<span class="code_quote" >'Unification errors.csv'</span>)

<span class="code_comment" >## Create animation of motion relative to neurocranium</span>
<span class="code_comment" ># Get relative motion</span>
relative_motion <- <span class="code_function" >relativeMotion</span>(motion=unify_motion$motion, fixed=<span class="code_quote" >'Neurocranium'</span>)

<span class="code_comment" ># Create animation with fixed neurocranium</span>
<span class="code_function" >svg.new</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'Animation fixed Neurocranium.html'</span>), mode=<span class="code_quote" >'webgl'</span>)
<span class="code_function" >for</span>(body_name in <span class="code_function" >names</span>(unify.spec)){
	<span class="code_function" >svg.mesh</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'meshes/Cat 01 '</span>, body_name, <span class="code_quote" >'.obj'</span>), name=body_name)
	markers_match <- <span class="code_function" >grepl</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'^'</span>, body_name, <span class="code_quote" >'_'</span>), <span class="code_function" >dimnames</span>(relative_motion$xyz)[[<span class="code_numeric" >1</span>]])
	body_markers <- <span class="code_function" >dimnames</span>(relative_motion$xyz)[[<span class="code_numeric" >1</span>]][markers_match]
	<span class="code_function" >svg.spheres</span>(relative_motion$xyz[body_markers,,], col=<span class="code_quote" >'yellow'</span>)
}
<span class="code_function" >svg.transform</span>(relative_motion$tmat, times=relative_motion$time)
frame <- <span class="code_function" >svg.frame</span>()
<span class="code_function" >svg.close</span>()

<span class="code_comment" >## Constraining body motion using virtual points</span>
<span class="code_comment" ># Create visual of virtual point</span>
<span class="code_function" >svg.new</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'Suspensorium virtual point.html'</span>), mode=<span class="code_quote" >'webgl'</span>)
<span class="code_function" >for</span>(body_name in <span class="code_function" >c</span>(<span class="code_quote" >'Neurocranium'</span>, <span class="code_quote" >'SuspensoriumL'</span>)){
	<span class="code_function" >svg.mesh</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'meshes/Cat 01 '</span>, body_name, <span class="code_quote" >'.obj'</span>), opacity=<span class="code_numeric" >0.5</span>)
	markers_match <- <span class="code_function" >grepl</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'^'</span>, body_name, <span class="code_quote" >'_'</span>), <span class="code_function" >dimnames</span>(read_motion$xyz)[[<span class="code_numeric" >1</span>]])
	body_markers <- <span class="code_function" >dimnames</span>(read_motion$xyz)[[<span class="code_numeric" >1</span>]][markers_match]
	<span class="code_function" >svg.spheres</span>(landmarks[body_markers,], col=<span class="code_quote" >'gray'</span>)
}
<span class="code_function" >svg.spheres</span>(landmarks[<span class="code_quote" >'Neurocranium-SuspensoriumL_nc_susp_jt_cra'</span>,], col=<span class="code_quote" >'red'</span>)
<span class="code_function" >svg.close</span>()

<span class="code_comment" ># Add virtual point to unify specifications</span>
unify.spec <- <span class="code_function" >list</span>(
	<span class="code_quote" >'Neurocranium'</span>=<span class="code_quote" >'^Neurocranium'</span>,
	<span class="code_quote" >'SuspensoriumL'</span>=<span class="code_function" >list</span>(
		<span class="code_quote" >'align'</span>=<span class="code_quote" >'^SuspensoriumL'</span>,
		<span class="code_quote" >'point'</span>=<span class="code_function" >list</span>(<span class="code_quote" >'Neurocranium'</span>=<span class="code_quote" >'Neurocranium-SuspensoriumL_nc_susp_jt_cra'</span>)),
	<span class="code_quote" >'LowerJawL'</span>=<span class="code_quote" >'^LowerJawL'</span>,
	<span class="code_quote" >'OperculumL'</span>=<span class="code_quote" >'^OperculumL'</span>
)

<span class="code_comment" ># Multiple virtual points</span>
unify_spec2 <- <span class="code_function" >list</span>(
	<span class="code_quote" >'Body1'</span>=<span class="code_quote" >'^Body1'</span>,
	<span class="code_quote" >'Body2'</span>=<span class="code_function" >list</span>(
		<span class="code_quote" >'align'</span>=<span class="code_quote" >'^Body2'</span>,
		<span class="code_quote" >'point'</span>=<span class="code_function" >list</span>(<span class="code_quote" >'Body1'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'Body1VirtualPoint1'</span>, <span class="code_quote" >'Body1VirtualPoint2'</span>)))
)

<span class="code_comment" ># Multiple virtual points</span>
unify_spec3 <- <span class="code_function" >list</span>(
	<span class="code_quote" >'Body1'</span>=<span class="code_quote" >'^Body1'</span>,
	<span class="code_quote" >'Body2'</span>=<span class="code_quote" >'^Body2'</span>,
	<span class="code_quote" >'Body3'</span>=<span class="code_function" >list</span>(
		<span class="code_quote" >'align'</span>=<span class="code_quote" >'^Body3'</span>,
		<span class="code_quote" >'point'</span>=<span class="code_function" >list</span>(
			<span class="code_quote" >'Body1'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'Body1VirtualPoint1'</span>, <span class="code_quote" >'Body1VirtualPoint2'</span>)),
			<span class="code_quote" >'Body2'</span>=<span class="code_function" >c</span>(<span class="code_quote" >'Body2VirtualPoint1'</span>, <span class="code_quote" >'Body2VirtualPoint2'</span>))
)

<span class="code_comment" ># Unify motion using a virtual point</span>
unify_motion <- <span class="code_function" >unifyMotion</span>(read_motion, xyz.mat=landmarks, unify.spec=unify.spec, 
	regexp=TRUE, plot.diag=<span class="code_quote" >'Unify.pdf'</span>)

<span class="code_comment" ># Get motion relative to the neurocranium</span>
relative_motion <- <span class="code_function" >relativeMotion</span>(unify_motion$motion, fixed=<span class="code_quote" >'Neurocranium'</span>)

<span class="code_comment" ># Create an animation with the virtual point</span>
<span class="code_function" >svg.new</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'Animation virtual fixed Neurocranium.html'</span>), mode=<span class="code_quote" >'webgl'</span>)
<span class="code_function" >for</span>(body_name in <span class="code_function" >names</span>(unify.spec)){
	<span class="code_function" >svg.mesh</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'meshes/Cat 01 '</span>, body_name, <span class="code_quote" >'.obj'</span>), name=body_name, opacity=<span class="code_numeric" >0.7</span>)
	markers_match <- <span class="code_function" >grepl</span>(<span class="code_function" >paste0</span>(<span class="code_quote" >'^'</span>, body_name, <span class="code_quote" >'_'</span>), <span class="code_function" >dimnames</span>(relative_motion$xyz)[[<span class="code_numeric" >1</span>]])
	body_markers <- <span class="code_function" >dimnames</span>(relative_motion$xyz)[[<span class="code_numeric" >1</span>]][markers_match]
	<span class="code_function" >svg.spheres</span>(relative_motion$xyz[body_markers,,], col=<span class="code_quote" >'yellow'</span>)
}
<span class="code_function" >svg.spheres</span>(landmarks[<span class="code_quote" >'Neurocranium-SuspensoriumL_nc_susp_jt_cra'</span>,], col=<span class="code_quote" >'red'</span>, name=<span class="code_quote" >'Neurocranium'</span>)
<span class="code_function" >svg.transform</span>(relative_motion$tmat, times=relative_motion$time)
frame <- <span class="code_function" >svg.frame</span>()
<span class="code_function" >svg.close</span>()
</pre></div>
		</div>

		<div id='footer' class='footer' >
			<div style='float:left;' >© 2019 Aaron Olsen. All rights reserved.<br><br></div>
			<div style='float:right;' >Design and photographs by Aaron Olsen.</div>
			<div style='float:left;background-color:;' >The material on this site is based upon work supported by the National Science Foundation (DGE-1144082, DGE-0903637, DBI-1612230). Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.</div>
		</div>

	</div>

</body>
<script src="../../js/sharedfunctions2.js" type="text/javascript" ></script>